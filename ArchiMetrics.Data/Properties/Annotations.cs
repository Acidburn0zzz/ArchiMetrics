// --------------------------------------------------------------------------------------------------------------------
// <copyright company="Reimers.dk" file="Annotations.cs">
//   Copyright © Reimers.dk 2012
//   This source is subject to the Microsoft Public License (Ms-PL).
//   Please see http://go.microsoft.com/fwlink/?LinkID=131993 for details.
//   All other rights reserved.
// </copyright>
// <summary>
//   Indicates that marked element should be localized or not.
// </summary>
// --------------------------------------------------------------------------------------------------------------------

namespace ArchiMetrics.Data.Properties
{
	using System;

	/// <summary>
	/// Indicates that the method is contained in a type that implements
	/// <see cref="System.ComponentModel.INotifyPropertyChanged"/> interface
	/// and this method is used to notify that some property value changed.
	/// </summary>
	/// <remarks>
	/// The method should be non-static and conform to one of the supported signatures:
	/// <list>
	/// <item><c>NotifyChanged(string)</c></item>
	/// <item><c>NotifyChanged(params string[])</c></item>
	/// <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
	/// <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
	/// <item><c>SetProperty{T}(ref T, T, string)</c></item>
	/// </list>
	/// </remarks>
	/// <example>
	/// <code>
	/// public class Foo : INotifyPropertyChanged
	/// {
	///   public event PropertyChangedEventHandler PropertyChanged;
	///
	///   [NotifyPropertyChangedInvocator]
	///   protected virtual void NotifyChanged(string propertyName)
	///   {}
	///
	///   private string _name;
	///   public string Name
	///   {
	///     get { return _name; }
	///     set
	///     {
	///       _name = value;
	///       NotifyChanged("LastName"); // Warning
	///     }
	///   }
	/// }
	/// </code>
	/// Examples of generated notifications:
	/// <list>
	/// <item><c>NotifyChanged("Property")</c></item>
	/// <item><c>NotifyChanged(() => Property)</c></item>
	/// <item><c>NotifyChanged((VM x) => x.Property)</c></item>
	/// <item><c>SetProperty(ref myField, value, "Property")</c></item>
	/// </list>
	/// </example>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	public sealed class NotifyPropertyChangedInvocatorAttribute : Attribute
	{
		public NotifyPropertyChangedInvocatorAttribute() { }
		public NotifyPropertyChangedInvocatorAttribute(string parameterName)
		{
			ParameterName = parameterName;
		}

		[UsedImplicitly]
		public string ParameterName { get; private set; }
	}

	/// <summary>
	/// Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
	/// so this symbol will not be marked as unused (as well as by other usage inspections)
	/// </summary>
	[AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)]
	public sealed class UsedImplicitlyAttribute : Attribute
	{
		[UsedImplicitly]
		public UsedImplicitlyAttribute()
			: this(ImplicitUseKindFlags.Default, ImplicitUseTargetFlags.Default) { }

		[UsedImplicitly]
		public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags)
		{
			UseKindFlags = useKindFlags;
			TargetFlags = targetFlags;
		}

		[UsedImplicitly]
		public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags)
			: this(useKindFlags, ImplicitUseTargetFlags.Default) { }

		[UsedImplicitly]
		public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags)
			: this(ImplicitUseKindFlags.Default, targetFlags) { }

		[UsedImplicitly]
		public ImplicitUseKindFlags UseKindFlags { get; private set; }

		/// <summary>
		/// Gets value indicating what is meant to be used
		/// </summary>
		[UsedImplicitly]
		public ImplicitUseTargetFlags TargetFlags { get; private set; }
	}

	[Flags]
	public enum ImplicitUseKindFlags
	{
		Default = Access | Assign | InstantiatedWithFixedConstructorSignature,

		/// <summary>
		/// Only entity marked with attribute considered used
		/// </summary>
		Access = 1,

		/// <summary>
		/// Indicates implicit assignment to a member
		/// </summary>
		Assign = 2,

		/// <summary>
		/// Indicates implicit instantiation of a type with fixed constructor signature.
		/// That means any unused constructor parameters won't be reported as such.
		/// </summary>
		InstantiatedWithFixedConstructorSignature = 4,

		/// <summary>
		/// Indicates implicit instantiation of a type
		/// </summary>
		InstantiatedNoFixedConstructorSignature = 8,
	}

	/// <summary>
	/// Specify what is considered used implicitly when marked with <see cref="MeansImplicitUseAttribute"/> or <see cref="UsedImplicitlyAttribute"/>
	/// </summary>
	[Flags]
	public enum ImplicitUseTargetFlags
	{
		Default = Itself,

		Itself = 1,

		/// <summary>
		/// Members of entity marked with attribute are considered used
		/// </summary>
		Members = 2,

		/// <summary>
		/// Entity marked with attribute and all its members considered used
		/// </summary>
		WithMembers = Itself | Members
	}
}
